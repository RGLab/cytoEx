#' A function that performs the marker selection.
#'
#' It combines all the following factors to determine which marker has the best the peak separation
#' 1. distance between two peaks
#' 2. height ratio between two peaks
#' 3. valley to peak(lower of the two peaks) height ratio
#' 4. area ratio between two peaks
#'
#' @param flist a list of filters/gates generated by mindensity method
#' @param fr flowFrame
#' @param min.percent the minimum ratio of two peak areas. The marker will be disqualified automatically when its measurement is lower than this threshold
#' @param ... passed to density function
#' @return an integer as the index of the winner gate. When it returns 0, it indicates that no further gating should be proceeded
#' @export
#' @import data.table
#' @examples
#' data(GvHD)
#' fr <- GvHD[[1]]
#'
#'  #  transform the raw data
#' channels <- c("FL1-H", "FL2-H", "FL3-H", "FL4-H")
#' trans <- estimateLogicle(fr, channels)
#' fr <- transform(fr, trans)
#'

#' #run the 1d gating on these channels
#' flist <- sapply(channels, function(channel)mindensity(fr, channel))
#'
#' #select the best marker
#' ind <- best.separation(flist, fr)
#' channels[ind] #winner channel
#'
#' objs <- best.separation(flist, fr, debug.mode = TRUE) #turn on the debug mode to display plots
#' objs[["metrics"]]
#' plot(objs[["plotObjs"]])
best.separation <- function(flist, fr, debug.mode = FALSE, plotEnv = new.env(parent = emptyenv()), ...){
  mat <- exprs(fr)

  #calculate the peak separation measurements
  res <- lapply(flist, function(gate){
    channel <- as.vector(parameters(gate))
    marker <- getChannelMarker(fr, channel)[, "desc"]
    valley.x <- gate@min #assuming it is always positive gate
    vec <- mat[, channel]
    peaks.result <- openCyto:::.find_peaks(vec, plot = FALSE,...)
    peaks.info <- peaks.result[["peaks"]]
    dens <- peaks.result[["dens"]]
    valley.ind <- which.min(abs(dens[, x] - valley.x))
    valley.y <- dens[valley.ind, y]
    #get the max peak from either side of valley
    left.peak <- peaks.info[x <= valley.x, ][1, ]
    right.peak <- peaks.info[x > valley.x, ][1, ]

    if(debug.mode){
      require(ggplot2)
      p <- ggplot(dens, aes(x = x, y)) + geom_line()
      p <- p + geom_point(data = left.peak, col = "red")
      p <- p + geom_point(data = right.peak, col = "blue")
      p <- p + geom_point(data = data.frame(x = valley.x, y = valley.y), pch = "V", col = "brown", cex = 3)
      p <- p + xlab(marker) + theme(axis.text.y= element_blank(), axis.title.y = element_blank(), axis.ticks.y = element_blank())
      plotEnv[[channel]] <- p
    }

    if(is.na(left.peak[,x])||is.na(right.peak[, x]))
    {
      peak.dist <- 0
      peak.ratio <- 0
      valley.peak.ratio <- 1
      area.ratio <- 0
    }else{

      left.area <- dens[1:valley.ind, sum(y)]
      total.area <- dens[, sum(y)]
      right.area <- total.area - left.area
      area.ratio <- min(left.area, right.area)/total.area
      peak.dist <- (right.peak[, x] - left.peak[, x])/diff(range(vec))

      peak.height <- c(left.peak[, y], right.peak[, y])
      peak.height.min <- min(peak.height)
      peak.height.max <- max(peak.height)
      peak.ratio <- peak.height.min/peak.height.max

      valley.peak.ratio <- valley.y/peak.height.min
    }
    data.table(peak.dist, peak.ratio, valley.peak.ratio, area.ratio)
  })
  res <- rbindlist(res, idcol = "channel")

  #standardize each metrics
  metrics <- sapply(colnames(res), function(cn){

    col <- res[[cn]]
    if(cn%in%c("channel", "area.ratio")) #skip these two columns
      val <- col
    else{
      min.col <- min(col)
      delta <- (max(col) - min.col)
      if(delta > 0)
        val <- (col- min.col)/delta
      else
        val <- rep(0, length(col))
    }

    return(val)
  }, simplify = FALSE)
  metrics <- as.data.table(metrics)
  metrics[, valley.peak.ratio:= 1- valley.peak.ratio] # invert v/p score
  # metrics[, valley.peak.ratio:= valley.peak.ratio] # reduce the weight of valley/peak ratio since it can be overweighted by the extreme low valley
  metrics[, score := rowMeans(.SD), .SDcols = c("valley.peak.ratio", "peak.dist", "peak.ratio", "area.ratio")]


  return(metrics)
}
